### 02-从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？
- 最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可 复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

### 03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？
>全书需要学习的技能预览: 我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含**面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。**
而我们整个专栏的内容也是围绕着这几块展开讲解的。
- 面向对象
现在,主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象又是这其中最主流的.需要掌握以下7点: 
  - 面向对象的四大特性：封装、抽象、继承、多态 
  - 面向对象编程与面向过程编程的区别和联系 
  - 面向对象分析、面向对象设计、面向对象编程 
  - 接口和抽象类的区别以及各自的应用场景 
  - 基于接口而非实现编程的设计思想 
  - 多用组合少用继承的设计思想 
  - 面向过程的贫血模型和面向对象的充血模型
- 设计原则
需要透彻理解并掌握以下原则
  - SOLID原则-SRP单一职责原则 
  - SOLID原则-OCP开闭原则 
  - SOLID原则-LSP里式替换原则 
  - SOLID原则-ISP接口隔离原则 
  - SOLID原则-DIP依赖倒置原则 
  - DRY原则、KISS原则、YAGNI原则、LOD法则
- 设计模式
掌握典型的应用场景，并且懂得不过度应用。23种经典的设计模式, 分以下3类, 着重讲常用
  - 创建型
    - 常用的：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 
    - 不常用的：原型模式。
  - 结构型
    - 常用的：代理模式、桥接模式、装饰者模式、适配器模式。 
    - 不常用的：门面模式、组合模式、享元模式。 
  - 行为型
    - 常用的：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
    - 不常用的：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。   
- 编程规范
总结了最能改善代码的20条规范
- 代码重构
在开发初期，除非特别必须，我们一定不要过度设计， 应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行 重构。这样就能有效避免前期的过度设计。
![WeChatWorkScreenshot_5fe6f37b-8fd9-4a74-bb14-11fa892930ef](https://user-images.githubusercontent.com/31027010/111027312-761c6f80-842a-11eb-92c5-00d5cbac8f1d.png)


### 05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？
  - 封装(Encapsulation): 封装也叫作信息隐藏或者数据访问保护
  - 抽象(Abstraction): 隐藏方法的具体实现，
  - 继承(Inheritance): 
  - 多态(Polymorphism): 子类可以替代父类
  
### 06-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？
  - 跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问 题的方式，是完全不一样的。前三者是一种计算机思维方式，
  而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去 执行这组指令，操作某些数据，
  帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，
  而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。

### 08-理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？
抽象类实际上就是类，只不过是一种特殊的类,是一种不能被实例化为对象，只能被子类继承。继承关系是一种is-a的关系,那抽象类既然属于类，也表示一种is-a的关系.
相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。
- 如何决定该用抽象类还是接口？
判断的标准很简单。如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种has-a关系，并且是为了解决抽象而非代码复用的问题，
那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。
而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。
    
### 09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？
基于接口而非实现编程,说得好理解点就是:基于抽象而非实现编程.这个原则非常重要,是一种非常有效的提高代码质量的手段.为什么说高效呢,
因为应用了这条规则,可以将接口和实现分离,封装了不稳定的实现,暴露稳定的接口.
如何做到基于接口而非实现编程基本需要做到如下3点:
   - 函数名称不能包含任何实现细节,改为更加抽象的命令方式.
   - 封装具体实现细节
   - 为实现类定义一个抽象接口.使用者则依赖于接口而不是具体的实现类来编程.
是否需要为每个类都定义个接口?
凡事有个度,判断需不需要定义个接口,我们看下这条原则设计初衷就明白了,初衷是:将接口与实现分离,封装不稳定的具体实现(实现是不稳定的).    
暴露稳定的接口.这样上游系统基于接口而非实现编程,不依赖于不稳定的实现细节.这样当实现变化时,上游系统代码基本不用怎么动,降低耦合度,提高扩展性.
所以在我们业务中某种功能的实现方式只有一种,或者如果是系统特别稳定,开发后基本不需维护,那么我么直接基于实现编程即可,而不用花时间去做基于接口编程.

## 10-理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？
组合优于继承,多用组合少用继承是条很经典的设计原则.我们鼓励多用组合少于继承,但是如果类之间的继承结构稳定,层次简单,关系不复杂那么可以大胆用继承,
反之则要尽量用组合,避免继承关系过于复杂.

## 13-实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？
所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，
而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

## 15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？
单一职责原则,SRP(Single Responsibility Principle), 也是SOLID中的S.其含义为: 一个类或者模块只负责完成一个职责（或者功能）。
作者用经验提供一些判断原则
- 一个类行数是否太多,属性函数太多.(多少算多其实要视情况,但若一定给个宽泛的值那就是最好不要超过200行)
- 类依赖的其他类过多, 不符合高内聚低耦合,那么就需考虑拆分
- 难给一个类起个合适的名字,很难用一个业务名词来概括,或者只能用一些笼统的名词来命名,那么说明这个类的职责定义得可能不够清晰.

## 16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？
什么是对扩展开放,对修改关闭?
其含义是:software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。
也称为开闭原则.也是SOLID中的O.这条规则很重要,因为在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的.主要遵从的设计原则就是开闭原则。

## 18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？
接口隔离原则(Interface Segregation Principle, ISP即SOLID中的I):Clients should not be forced to depend upon interfaces that 
they do not use.客户端不应该被强迫依赖它不需要的接口。其中“客户端”，可理解为接口的调用者或者使用者。

## 19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？
- 控制反转(inversion of control)
实际上,控制反转是一个比较笼统的设计思想,并不是一种具体的方向方法.一般用来指导框架层面的设计.这里的"控制"是指对程序执行流程的控制,而"反转"是指在没有
使用框架前,程序员自己控制程序执行流程,而使用了框架后,整个执行流程通过框架来控制.流程的控制权从程序员"反转"给了框架.
- 依赖注入(Dependency Injection)
依赖注入和控制反转恰恰相反,依赖注入是控制反转的一种具体的编码技巧.其实依赖注入一个听起来"高大上"但实际很简单.一句话概括就是: 不通过new()在类内部
创建依赖对象,而是将依赖的对象在外部创建好后通过构建函数,函数参数等方式传递给类使用.
- 依赖反转(Dependency Inversion Principle, 即是SOLID的D,作者没有给这条很详细的解释)
高层模块（high-level modules）不要依赖低层模块 （low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之 外，
抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖 抽象（abstractions）

## 20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？
- KISS原则(英文版描述有好几种,keep it simple and stupid, keep it short and simple, keep it simple and straightforward, 不过想
表达的东西其实差不多,即是: 尽量保持简单)
   - KISS是维护代码可读和可维护性的重要手段.代码足够简单,也就意味着容易读懂,**bug比较难隐藏**,即使出现修复起来也比较简单.
   - 落地实现: 
     - 不要过度优化,过度使用一些奇技淫巧来优化代码,而牺牲了代码的可读性.(对于性能不是很在乎,没必要过度优化而去牺牲了可读性)
     当然逻辑复杂、实现难度大,像这种本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。实际上,代码是否简单也比较主观因人而异,但有个很有效的间接
     方法,就是当同事review你代码时有很疑问,说明你的代码还不够简单,需要优化了.我还想多说两句，我们在做开发的时候，一定不要过度设计，
     不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。
- YAGNI原则(You Ain’t Gonna Need It)    
  不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。
  
## 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？
实际上，不仅仅是软件设计开发，不管做任何事情，如果我们总是等到所有的东西都想好了 再开始，那这件事情可能永远都开始不了。。我这个有十多年工作经验的人尚且如此，
对于没有太多经验的开发者来说，想一 下子把所有需求都实现出来，更是一件非常有挑战的事情。一旦无法顺利完成，你可能就会 有很强的挫败感，就会陷入自我否定的情绪中.
不过，即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没 有产出，你的leader会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、
逐 步迭代是一种更好的开发模式。所以，我们应该分多个版本逐步完善这个框架。第一个版本 可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要 求，
在后续的v2.0、v3.0……版本中继续迭代优化。
写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些 大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，
我们熟悉的 Unix系统，第一版很简单、粗糙，代码不到1万行。所以，迭代思维很重要，不要刚开始就追 求完美。 

### 27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？
软件设计大师Martin Fowler是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”
- 为什么要从重构?(why)
时刻保证代码质量,不让代码往越来越混乱的方向演进.此外重构对一个工程师的成长也有着重要意思,所谓"初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码"
这句话的意思是说，初级工程师在已 有代码框架下修改bug、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框 架；而资深工程师为代码质量负责，
需要发觉代码存在的问题，重构代码，时刻保证代码质 量处于一个可控的状态(当然这里的初级、高级、资深只是一个相对概念,并不是一个确定的职级)
- 重构什么?(what)
分为大型重构和小型重构.
  - 大型重构: 包括：系统、模块、代码结构、类与类之间的关系 等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等
  - 小型重构: 指对代码细节的重构,主要是针对类、函数、变量等代码级别的重构，比如规 范命名、规范注释、消除超大类或函数、提取重复代码等等
- 什么时候要重构?(when)
作者提倡的重构策略是:持续重构,将重构作为日常开发中一部分,而不是发现问题时,再大刀阔斧.

### 28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？
代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难 为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，
那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函 数、全局变量、代码高度耦合等。
写单元测试真的是件很耗时的事情吗？
写单元测试的代码量可能是被测试代码的1~2倍,写的过程很繁琐,但并不是耗时,因为测试代码实现起来比较简单,不同测试用例差别不大,简单copy-paste改改就行.

### 29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？
依赖注入是编写可测试性代码的最有效手段

## 31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）  
对于代码可读性,起名很重要.作者说的小窍门,如果实在想不到好名字,可以去github用相关的关键词联想搜索下,看看类似的代码是怎么命名的.

## 32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）
- 类,行多大?
不能太多,但也不能太少.行数太多,逻辑多于复杂,容易阅读后面代码就忘了前面的;相反行数太少,在代码总量不变的情况下,被分割成的类和函数就会增多,调用关系就会
变得更复杂.
- 四格缩进还是两格缩进?
不同语言可能会不一样,只要项目中统一,四个和两个都可.php倾向于四格.此外,值得注意是一定不要使用tab缩进,因为不同IDE下tab键宽度不一样,有的显示两格缩进,
有的四格缩进.
  
## 33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）
- 避免函数参数过多
作者觉得函数参数大等于5个时,参数就有点多了,影响阅读,使用时也不方便.一般有两种方法:
  - 考虑函数职责是否单一,是否能通过拆分成多个函数来减少参数.
  - 将传入的参数封装成对象
  
## 36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？
- 程序出错返回啥?
最常用的函数出错处理方式就是抛出异常也是推荐的。异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。
- 如果处理函数抛出的异常? 吞掉,原封不动的re-throw,包装新的异常抛出
    - 是否往上抛出异常? 要看上层代码是否关心这个异常. 关心就抛出,否则就直接吞掉
    - 是否需要包装成新的异常抛出? 看上层代码是否能理解这个错误, 可以直接抛出, 不能则需包装成新的重新抛出.
    
## 48 | 代理模式：代理在RPC、缓存、监控等场景中的应用
> (对自己感觉是比较新的知识,有学到新的东西)
- 代理模式的原理与实现?
在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，
并且原 始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法 来实现代理模式。
- 代理模式的应用场景
代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事 务、幂等、日志。**我们将这些附加功能与业务功能解耦**，放到代理类统一处理，让程序员只
需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。

## 51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？
适配器模式: 即是将原本不兼容的接口通过再包一层转换为想要的接口(也就是兼容好的接口). 这个包一层的就是适配器做的事.

## 52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？
定义: 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。自己理解的大白话: 即是将粒度更小的模块(小模块可理解为类,函数等)组合起来
向外提供能完成某个功能的一个接口.

## 56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式
观察者模式（Observer Design Pattern）也被称为发布订阅模式,在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
> **设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。** 

## 58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用
模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
这里的“算法”，我们可以理解为广义上的“业务逻辑”. (看下文中的代码例子就会很容易理解.)

## 60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？
## 61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？
学习到一种去除if-else/switch分支的方法. 也就是"查表法", 即是放在一个数组中,if的条件为key,动作为value.(具体可见文中案例)
**对于多个数值区间范围的if-else, 可以使用文中所列的方法,也是查表法.(可以学习下,新知识有收获)**

## 62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？
职责链模式:多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，
以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。
当然，在开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。应用场景: 如过滤器(敏感词过滤器,请求过滤器)
职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。